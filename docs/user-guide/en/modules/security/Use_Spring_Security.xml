<!--

    Copyright (C) 2009 eXo Platform SAS.
    
    This is free software; you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation; either version 2.1 of
    the License, or (at your option) any later version.
    
    This software is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public
    License along with this software; if not, write to the Free
    Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
    02110-1301 USA, or see the FSF site: http://www.fsf.org.

-->

<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook V4.4//EN" "http://www.oasis-open.org/docbook/sgml/4.4/docbookx.dtd">
<section>
	<title>Use Spring Security</title>
	<section>
		<title>Overview</title>
	</section>
	<para>This tutorial will bring you through a few steps and show you
		how easy it is to integrate spring security (or the Spring framework
		in general) in GateIn portal. We will create a login portlet example
		as a support all along the document reading. The login portlet example
		has been developed and deployed using the GateIn WCM product running
		on the application server JBoss 4.2.3. But it can easily be adapted to
		another GateIn product (such as ECM) and to other servers such as
		tomcat. Moreover, the example, claiming to be a real world example, is
		implemented using JSF 1.2, the JBoss portlet bridge and Spring and can
		serve as a example project from where you can start your own portlet
		development targeting the GateIn platform.</para>
	<section>
		<title>Installation</title>
	</section>
	<para>This tutorial assumes that you have a working GateIn
		installation running under JBoss 4.2.x. (TODO: Since we only provide
		JBoss 5.1.x, we need to check what's still relevant)</para>
	<para>
		Download the spring framework:
		<ulink
			url="http://s3.amazonaws.com/dist.springframework.org/release/SPR/spring-framework-2.5.6-with-dependencies.zip">http://s3.amazonaws.com/dist.springframework.org/release/SPR/spring-framework-2.5.6-with-dependencies.zip</ulink>
	</para>
	<para>
		Download spring-security:
		http://sourceforge.net/project/showfiles.php?group
		<emphasis>id=73357&amp;package</emphasis>id=270072&amp;release<link linkend="id=630203">id=630203</link></para><para>Explode the 02portal.war file in the jboss server/default/deploy/exoplatform.sar directory and copy the following jars in WEB-INF/lib:</para><itemizedlist><listitem>spring.jar</listitem><listitem>spring-security-core.jar</listitem><listitem>aspectjrt-1.5.4.jar</listitem><listitem>exo-spring.jar (contains the filters and event handlers described in this tutorial - see attachment section of this page)</listitem></itemizedlist>
<section><title>Configuration</title></section>
<para>To enable spring security in GateIn we need to go through a few configuration steps:</para>
<section><title>JAAS disabling</title></section>
<para>First we need to disable the JAAS security which is the default authentication mechanism in exo. Edit 02portal.war web.xml file and comment out the JAAS configuration related lines:</para><programlisting>...
    &lt;session-config&gt;
        &lt;session-timeout&gt;15&lt;/session-timeout&gt;
    &lt;/session-config&gt;
    &lt;!--
    &lt;security-constraint&gt;
        &lt;web-resource-collection&gt;
            &lt;web-resource-name&gt;user
                authentication&lt;/web-resource-name&gt;
            &lt;url-pattern&gt;/private/*&lt;/url-pattern&gt;
            &lt;http-method&gt;POST&lt;/http-method&gt;
            &lt;http-method&gt;GET&lt;/http-method&gt;
        &lt;/web-resource-collection&gt;
        &lt;auth-constraint&gt;
            &lt;role-name&gt;users&lt;/role-name&gt;
        &lt;/auth-constraint&gt;
        &lt;user-data-constraint&gt;
            &lt;transport-guarantee&gt;NONE&lt;/transport-guarantee&gt;
        &lt;/user-data-constraint&gt;
    &lt;/security-constraint&gt;
   
    &lt;login-config&gt;
        &lt;auth-method&gt;FORM&lt;/auth-method&gt;
        &lt;realm-name&gt;exo-domain&lt;/realm-name&gt;
        &lt;form-login-config&gt;
            &lt;form-login-page&gt;/login/jsp/login.jsp&lt;/form-login-page&gt;
            &lt;form-error-page&gt;/login/jsp/login.jsp&lt;/form-error-page&gt;
        &lt;/form-login-config&gt;
    &lt;/login-config&gt;
    --&gt;
    &lt;security-role&gt;
        &lt;description&gt;a simple user role&lt;/description&gt;
        &lt;role-name&gt;users&lt;/role-name&gt;
    &lt;/security-role&gt;
...
</programlisting><para>1.1 Enabling spring security</para><para>To enable spring and set the spring security filter, add the following lines:</para><programlisting>...
    &lt;context-param&gt;
        &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
        &lt;param-value&gt;/WEB-INF/security-context.xml&lt;/param-value&gt;
    &lt;/context-param&gt;
    &lt;listener&gt;
        &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
    &lt;/listener&gt;
    &lt;filter&gt;
        &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
        &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
    &lt;/filter&gt;
...
</programlisting><para>Activate the spring security filter at the right position, i.e. just after the filter responsible of exo container initialization.</para><programlisting>...
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;PortalContainerInitializedFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;SetCurrentIdentityFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
    &lt;/filter-mapping&gt;
...
</programlisting><para>1.1 security-context.xml</para><para>We need to configure the spring security filter chain for our purposes. Create a file named security-context.xml in 02portal.war WEB-INF directory containing the following lines:</para><programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans:beans xmlns=&quot;http://www.springframework.org/schema/security&quot;
    xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.0.xsd
                        http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security-2.0.1.xsd&quot;&gt;
    &lt;http auto-config=&quot;true&quot;&gt;
        &lt;intercept-url pattern=&quot;/private/**&quot; access=&quot;ROLE_USER&quot; /&gt;   
        &lt;form-login login-page='/public/classic/Login' default-target-url='/private/classic/home' /&gt;
    &lt;/http&gt;
  
    &lt;authentication-provider&gt;
         &lt;user-service&gt;
            &lt;user name=&quot;rod&quot; password=&quot;koala&quot; authorities=&quot;ROLE_SUPERVISOR, ROLE_USER, ROLE_TELLER&quot; /&gt;
          &lt;user name=&quot;root&quot; password=&quot;exo&quot; authorities=&quot;ROLE_USER&quot; /&gt;
     &lt;/user-service&gt;
    &lt;/authentication-provider&gt;   
&lt;/beans:beans&gt;
</programlisting><para>The file contains two elements. The http node which is responsible of configuring the filter chain. The auto-config mode set to true allows us to do just a minimal configuration, everything else being smartly initialized by default. We just set an intercept URL pointing to '/private/<emphasis role="bold"></emphasis>' with the ROLEUSER authority which corresponds to secured resources in exo. In case of successful auhentication, the user will be redirected to the specified default target URL.</para><para>The second element defines a simple authentication provider based on the spring security InMemoryDaoImpl implementation of the UserDetailsService. Note that we define the exo root user in the configuration which will allow us to log in with admin privileges in the exo portal.</para>
<section><title>Login portlet example</title></section>
<para>Now that we have successfully installed and configured spring security in exo, we need a login portlet example to capture user credentials and serve as an entry point in the authentication process. The login portlet itself is based on JSF 1.2, Jboss portlet bridge and the spring framework, but you can obviously use whatever web framework you want to achieve the same.</para>
<section><title>Building the portlet</title></section>
<para>So we need a login form to capture user credentials inputs. The portlet login form consists of the following lines of xml:</para><programlisting>&lt;f:view xmlns:f=&quot;http://java.sun.com/jsf/core&quot;
    xmlns:h=&quot;http://java.sun.com/jsf/html&quot;
    xmlns:ice=&quot;http://www.icesoft.com/icefaces/component&quot;
    xmlns:liferay-faces=&quot;http://liferay.com/tld/faces&quot;
    xmlns:ui=&quot;http://java.sun.com/jsf/facelets&quot;
    xmlns:c=&quot;http://java.sun.com/jstl/core&quot;
    xmlns:fn=&quot;http://java.sun.com/jsp/jstl/functions&quot;
    xmlns:t=&quot;http://myfaces.apache.org/tomahawk&quot;&gt;   
           
    &lt;style type=&quot;text/css&quot; media=&quot;screen&quot;&gt;   
      @import &quot;/loginportlet/css/starter.css&quot;;
      @import &quot;/loginportlet/css/uni-form.css&quot;;
    &lt;/style&gt;
    &lt;script src=&quot;/loginportlet/js/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;/loginportlet/js/uni-form.jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
       
    &lt;h:form styleClass=&quot;uniForm&quot; &gt;
        &lt;fieldset class=&quot;inlineLabels&quot;&gt;
            &lt;legend&gt;Sign in&lt;/legend&gt;       
         &lt;div class=&quot;ctrlHolder&quot;&gt;            
            &lt;h:outputLabel for=&quot;login&quot; style=&quot;width: 70px&quot;&gt;&lt;em&gt;*&lt;/em&gt;Login:&lt;/h:outputLabel&gt;
            &lt;h:inputText id=&quot;login&quot; value=&quot;{{loginBean.login}&quot; required=&quot;true&quot; styleClass=&quot;textInput&quot; /&gt;         
            &lt;h:message for=&quot;login&quot; styleClass=&quot;portlet-msg-error&quot; /&gt;
         &lt;/div&gt;
         &lt;div class=&quot;ctrlHolder&quot;&gt;        
            &lt;h:outputLabel for=&quot;password&quot; style=&quot;width: 70px&quot;&gt;&lt;em&gt;*&lt;/em&gt;Password:&lt;/h:outputLabel&gt;
            &lt;h:inputSecret id=&quot;password&quot; value=&quot;#{loginBean.passwd}&quot; required=&quot;true&quot; styleClass=&quot;textInput&quot; /&gt;
            &lt;h:message for=&quot;password&quot; styleClass=&quot;portlet-msg-error&quot; /&gt;        
         &lt;/div&gt;       
        &lt;/fieldset&gt;
   
         &lt;div class=&quot;buttonHolder&quot; style=&quot;margin-top: 20px; margin-right: 20px&quot;&gt;
             &lt;h:commandButton styleClass=&quot;primaryAction&quot; value=&quot;Submit&quot; action=&quot;#{loginBean.login}&quot; /&gt;                          
        &lt;/div&gt;
    &lt;/h:form&gt;
&lt;/f:view&gt;
</programlisting><para>The interesting part resides in the backing bean which implements the login action triggered when the user clicks the login form submit button.</para><programlisting>package org.exoplatform.loginportlet;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Controller;
@Controller
@Scope}
request
{{loginBean.login}&quot; required=&quot;true&quot; styleClass=&quot;textInput&quot; /&gt;         
            &lt;h:message for=&quot;login&quot; styleClass=&quot;portlet-msg-error&quot; /&gt;
         &lt;/div&gt;
         &lt;div class=&quot;ctrlHolder&quot;&gt;        
            &lt;h:outputLabel for=&quot;password&quot; style=&quot;width: 70px&quot;&gt;&lt;em&gt;*&lt;/em&gt;Password:&lt;/h:outputLabel&gt;
            &lt;h:inputSecret id=&quot;password&quot; value=&quot;#{loginBean.passwd}&quot; required=&quot;true&quot; styleClass=&quot;textInput&quot; /&gt;
            &lt;h:message for=&quot;password&quot; styleClass=&quot;portlet-msg-error&quot; /&gt;        
         &lt;/div&gt;       
        &lt;/fieldset&gt;
   
         &lt;div class=&quot;buttonHolder&quot; style=&quot;margin-top: 20px; margin-right: 20px&quot;&gt;
             &lt;h:commandButton styleClass=&quot;primaryAction&quot; value=&quot;Submit&quot; action=&quot;#{loginBean.login}&quot; /&gt;                          
        &lt;/div&gt;
    &lt;/h:form&gt;
&lt;/f:view&gt;
</programlisting><para>The interesting part resides in the backing bean which implements the login action triggered when the user clicks the login form submit button.</para><programlisting>package org.exoplatform.loginportlet;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Controller;
@Controller
@Scope}
public class LoginBean {
    String login;
    String passwd;
    public String login() throws Exception {
        String redirect = &quot;/portal/j_spring_security_check?j_username=&quot; + login + &quot;&amp;j_password=&quot; + passwd;
        PortalUtils.sendRedirect(redirect);       
        return null;
    }
    ...
}
</programlisting><para>The login action simply sends a HTTP redirect to the spring security login URL passing the user login and password as parameters. This URL informs the filter to try to authenticate the supplied user credentials. This is the Spring security authentication process entry point.</para><para>1.1 Setting up the login portal page</para><para>Now that we have a login portlet available we need to set it up into a portal page.</para><itemizedlist><listitem>Log in as root in exo portal.</listitem><listitem>Go to application registry and import the loginportlet</listitem><listitem>Add a new hidden page named 'Login' under the portal classic's navigation (read more on page creation here<link linkend="WCM.Tutorial">WCM.Tutorial</link>). Make sure that the visible flag is unchecked to hide the page. Also declare the page as public so that everyone can access it without being authenticated for obvious reasons.</listitem><listitem>Finally, drag &amp; drop the login portlet in the page with the desired layout.</listitem></itemizedlist><para>1.1 Customization of portal login and logout urls</para><para>In the portal header there is a login or logout action displayed depending whether you are already logged in or not. We need to customize those actions so that when the user clicks on it it will be redirect either to our login page or to the spring security logout url. Edit the article, go to the default.js tab and apply the following changes to the code:</para><programlisting>function validateUser() {
    var user = GateIn.env.portal.userName;
    var rootObj = document.getElementById(&quot;classic-access&quot;);
    var loginContentObj = GateIn.core.DOMUtil.findFirstDescendantByClass(rootObj, &quot;div&quot;, &quot;UIWCMLoginPortlet&quot;);
    var welcomeObj = GateIn.core.DOMUtil.findFirstDescendantByClass(rootObj, &quot;span&quot;, &quot;Welcome&quot;);
    var userObj = GateIn.core.DOMUtil.findFirstDescendantByClass(rootObj, &quot;span&quot;, &quot;LoggedUser&quot;);
    var languageObj = GateIn.core.DOMUtil.findFirstDescendantByClass(rootObj, &quot;a&quot;, &quot;LanguageIcon&quot;);
    var logXXXObj = GateIn.core.DOMUtil.findPreviousElementByTagName(languageObj, &quot;a&quot;);
    if (user!images/= &quot;null&quot;) {
        welcomeObj.innerHTML = &quot;Welcome: &quot;;       
        userObj.innerHTML = user;
        logXXXObj.innerHTML = &quot;Logout&quot;;
        if (GateIn.core.DOMUtil.hasClass(logXXXObj, &quot;LoginIcon&quot;)) {
            GateIn.core.DOMUtil.removeClass(logXXXObj, &quot;LoginIcon&quot;);
            GateIn.core.DOMUtil.addClass(logXXXObj, &quot;LogoutIcon&quot;);
        }
        logXXXObj.onclick = function() { document.location.href = '/portal/j_spring_security_logout' }
    } else {
        if (GateIn.core.DOMUtil.hasClass(logXXXObj, &quot;LogoutIcon&quot;)) {
            GateIn.core.DOMUtil.removeClass(logXXXObj, &quot;LogoutIcon&quot;);
            GateIn.core.DOMUtil.addClass(logXXXObj, &quot;LoginIcon&quot;);
        }
        logXXXObj.innerHTML = &quot;Login&quot;;
        logXXXObj.onclick = function() { document.location.href = '/portal/public/classic/Login' };
    }
    languageObj.onclick = function () { if(document.getElementById('UIMaskWorkspace')) ajaxGet(GateIn.env.server.createPortalURL('UIPortal', 'ChangeLanguage', true)); }
}
GateIn.core.Browser.addOnLoadCallback(&quot;validateUser&quot;, validateUser);
</programlisting><para>As you can see, the two onclick event handler function bodies have been changed to a simple redirect to the login page or the logout URL.</para><para>1.1 A look at the login page</para><para>Once you are done with all this, just click on the login action and you should be redirect to the login page looking something like that:</para><mediaobject><imageobject><imagedata fileref="images/LoginPage.png" format="PNG"></imagedata></imageobject></mediaobject><para>1 Integration strategies</para><para>Until now we haven't discussed about any integration strategies concerning a potential existing security realm outside of the GateIn platform. To address this problem we have the choice between at least two different strategies:</para><para>1.1 Direct integration We can directly integrate GateIn with the external realm. Everything related to organisation and user management in exo is cleanly separated in its own abstraction accessible through the OrganisationService. The authentication process itself is encapsulated in the Authenticator abstraction which sits on top of the organization service. GateIn provides several implementations of both. So whether your realm is based on LDAP or JDBC and because the default implementations are generic enough, you will be able to use them and fits them to your needs with a matter of a little configuration. You can even develop a custom implementation to meet your more specific needs.</para><para>1.1 Replication</para><para>Or we can go through a replication process between the external realm and the GateIn platform realm. This is the strategy that we are going to use to build our login portlet example. Furthermore the replication will occur dynamically on any user authentication attempt.</para><para>1 Integration with GateIn portal</para><para>Being successfully authenticated against an external realm is not sufficient by itself. We also need to propagate the newly created security context to the portal own security mechanism. In GateIn portal terminology, it means we have to create an Identity object for the user and register it into the Identity Registry.</para><para>Spring framework provides a simple notification model where a bean can listen to application events published by other beans. Fortunately spring security uses this mechanism and publishes an InteractiveAuthenticationSuccessEvent in case of successful authentication. That will allow us to hook up custom code to that event.</para><para>Furthermore, we need to replicate the user details from the external realm to the GateIn portal one according to the integration strategy defined above.</para><para>We create a SpringSecurityEventHandler bean that implements the ApplicationListener interface and listen to the InteractiveAuthenticationSuccessEvent event.</para><programlisting>package org.exoplatform.spring.security.web;
...
public class SpringSecurityEventHandler implements ApplicationListener {
    private String portalContainerName = &quot;portal&quot;;
    public void onApplicationEvent(ApplicationEvent event) {
        if (event instanceof InteractiveAuthenticationSuccessEvent) {
            try {
                InteractiveAuthenticationSuccessEvent successEvent = (InteractiveAuthenticationSuccessEvent) event;
                ExoContainer container = getContainer();
                String login = successEvent.getAuthentication().getName();
                String passwd = successEvent.getAuthentication().getCredentials().toString();
                IdentityRegistry identityRegistry = (IdentityRegistry) container.getComponentInstanceOfType(IdentityRegistry.class);
                Authenticator authenticator = (Authenticator) container.getComponentInstanceOfType(Authenticator.class);
                OrganizationService orgService = (OrganizationService) container.getComponentInstanceOfType(OrganizationService.class);
                User user = orgService.getUserHandler().findUserByName(login);
                if (user == null) {
                    user = orgService.getUserHandler().createUserInstance(login);               
                    user.setFirstName(login);
                    user.setLastName(login);
                    orgService.getUserHandler().createUser(user, false);   
                    orgService.getUserHandler().saveUser(user, false);
                    //TODO: put some more integration code here
                }
                Identity identity = authenticator.createIdentity(login);
                Subject subject = new Subject();
                subject.getPrivateCredentials().add(passwd);
                subject.getPublicCredentials().add(new UsernameCredential(login));
                identity.setSubject(subject);
                identityRegistry.register(identity);
            } catch (Exception e) {
                e.getMessage();
            }
        }
    }
    protected ExoContainer getContainer() {
        // TODO set correct current container
        ExoContainer container = ExoContainerContext.getCurrentContainer();
        if (container instanceof RootContainer) {
            container = RootContainer.getInstance().getPortalContainer(portalContainerName);
        }
        return container;
    }
...
}
</programlisting><para>Basically the bean retrieves user login and password from the InteractiveAuthenticationSuccessEvent object and tries to get the user from the organization service. In case he cannot find it in the repositoiry, he simply creates it on the fly. In this example the user is created with just a few details, but you can put some custom integration code with the external realm here, and create the user with all the details (email, birth date, roles, etc.) it seems appropriate to you. After that, the bean creates an Identity object with the help of the authenticator service, populates it with a subject containing the user credentials and registers it. That's all we have to do to make the portal aware of the user logging in.</para><para>Registering our bean is done the usual way in security-context.xml file:</para><programlisting>...
&lt;beans:bean id=&quot;myEventHandler&quot; class=&quot;org.exoplatform.spring.security.web.SpringSecurityEventHandler&quot; /&gt;
...
</programlisting>
<section><title>Security context propagation to portlets</title></section>
<para>Part of the problem is the question of security context propagation between on one side the portal webapp and at the other side the portlets webapps. This means that the security context has to be available in the portlet side allowing the application logic to deal with current user principal and granted authorities. By default Spring security uses a thread local variable to partially achieve this. But a problem may arise due to the fact that the portal invokes the portlet through a webapp cross context call. This means that it can lead to class cast exceptions (two different classloaders involved) or the security context simply not propagated at all. To accommodate this we will need to set up two request filters, one at the portal webapp side and the other at the portlet webapp side and use the http request to propagate the context in between.</para>
<section><title>Portal side filter</title></section>
<para>We will use the spring security extensible filter chain to plug in our filter.</para><programlisting>package org.exoplatform.spring.security.web;
...
public class PortalSideSecurityContextFilter extends SpringSecurityFilter {
    @Override
    protected void doFilterHttp(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
        //fill request with security context
        SecurityContext context = SecurityContextHolder.getContext();       
         request.setAttribute(HttpSessionContextIntegrationFilter.SPRING_SECURITY_CONTEXT_KEY, context);       
        
         //fill request with security last exception
         Object e = request.getSession().getAttribute(AbstractProcessingFilter.SPRING_SECURITY_LAST_EXCEPTION_KEY);
        request.setAttribute(AbstractProcessingFilter.SPRING_SECURITY_LAST_EXCEPTION_KEY, e);
       
        chain.doFilter(request, response);
    }
    public int getOrder() {
        // TODO Auto-generated method stub
        return 0;
    }
}
</programlisting><para>The PortalSideSecurityContextFilter simply fills the request with the security context and security last exception using the HttpSessionContextIntegrationFilter.SPRING<emphasis>SECURITY</emphasis>CONTEXT<emphasis>KEY and AbstractProcessingFilter.SPRING</emphasis>SECURITY<emphasis>LAST</emphasis>EXCEPTION<emphasis>KEY attribute names. The portlet can have a look to the AbstractProcessingFilter.SPRING</emphasis>SECURITY<emphasis>LAST</emphasis>EXCEPTIONKEY attribute to check if a security exception has occured.</para><para>The following lines in the security-context file register our custom filter in the chain at the last position.</para><programlisting>...
    &lt;beans:bean id=&quot;myCustomFilter&quot; class=&quot;org.exoplatform.spring.security.web.PortalSideSecurityContextFilter&quot;&gt;
        &lt;custom-filter after=&quot;LAST&quot; /&gt;
      &lt;/beans:bean&gt;
...
</programlisting><para>1.1 Portlet side filter</para><para>In the portlet webapp we create a regular filter named PortletSideSecurityContextFilter.</para><programlisting>package org.exoplatform.spring.security.web;
...
public class PortletSideSecurityContextFilter implements Filter {
    public void destroy() {       
       
    }
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {
        Object object = request.getAttribute(HttpSessionContextIntegrationFilter.SPRING_SECURITY_CONTEXT_KEY);
        SecurityContext context = (SecurityContext) serializeDeserialize(object);
        if (context!images/= null) {
            SecurityContextHolder.setContext(context);
        } else {
            SecurityContextHolder.clearContext();
        }       
       
        filterChain.doFilter(request, response);
    }
    public void init(FilterConfig arg0) throws ServletException {       
       
    }
    private Object serializeDeserialize(Object obj) {
        Object result = null;       
        try {
            ByteArrayOutputStream bout = new ByteArrayOutputStream();
            ObjectOutputStream out = new ObjectOutputStream(bout);
            out.writeObject(obj);
            ByteArrayInputStream bin =    new ByteArrayInputStream(bout.toByteArray());
            ObjectInputStream in = new ObjectInputStream(bin);
            result = in.readObject();           
        } catch (Exception e) {
            //TODO: handle exception
        }
        return result;
    }
   
}
</programlisting><para>The PortletSideSecurityContextFilter retrieves the security context from the request and proceeds to a serialization de-serialization of it to avoid a potential class cast exception that may occur when propagating object across webapps. Then the context is simply set or cleared whether the context is null or not.</para><para>To register your filter simply add the following lines to your portlet webapp web.xml file.</para><programlisting>...
    &lt;filter&gt;
        &lt;filter-name&gt;portletSideSecurityContextFilter&lt;/filter-name&gt;
        &lt;filter-class&gt;org.exoplatform.spring.security.web.PortletSideSecurityContextFilter&lt;/filter-class&gt;
    &lt;/filter&gt;
     
    &lt;filter-mapping&gt;
        &lt;filter-name&gt;portletSideSecurityContextFilter&lt;/filter-name&gt;
        &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
        &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt;
        &lt;dispatcher&gt;INCLUDE&lt;/dispatcher&gt;
        &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;
    &lt;/filter-mapping&gt;
...
</programlisting>
<section><title>Conclusion</title></section>
<para>We are done! Now we know how to integrate the spring security framework in the GateIn portal. Thanks to the the great integration capabilities of both GateIn portal and Spring framework. You can have a look to the attachment section on this page and get the source code of this tutorial.</para>
</section>