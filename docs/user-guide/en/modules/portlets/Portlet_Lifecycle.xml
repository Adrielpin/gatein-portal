<!--

    Copyright (C) 2009 eXo Platform SAS.
    
    This is free software; you can redistribute it and/or modify it
    under the terms of the GNU Lesser General Public License as
    published by the Free Software Foundation; either version 2.1 of
    the License, or (at your option) any later version.
    
    This software is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
    Lesser General Public License for more details.
    
    You should have received a copy of the GNU Lesser General Public
    License along with this software; if not, write to the Free
    Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
    02110-1301 USA, or see the FSF site: http://www.fsf.org.

-->

<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook V4.4//EN" "http://www.oasis-open.org/docbook/sgml/4.4/docbookx.dtd">
<section>
	<title>Portlet Lifecycle</title>
	<section>
		<title>Overview</title>
	</section>
	<para>The goal of this chapter is not to talk about the Portlet API
		specification lifecycle but more about GateIn UI framework to easily
		develop portlets.</para>
	<para>The web framework used here has been completely developed by
		GateIn and perfectly suits the portal environment, it even allows to
		send events from the portlet UIComponents to the Portal ones.</para>
	<para>Of course using the GateIn web framework to build portlets is
		not necessary and any other web framework that supports portlet
		environment can be used. But all GateIn portlets that are part of
		GateIn products are developed using that framework and we provide
		several UI components that can be used in different abstracted
		contexts such as the portal itself or some portlets.</para>
	<para>
		This chapter is not a tutorial on how to write portlets, it will go in
		the details of the code implementation and logic; hence it is intended
		for advanced developers. It is also advised to read the
		<link linkend="Portal Lifecycle">Portal Lifecycle</link>
		article before as the that article explains concepts that are similar
		and top hierarchy classes that are shared.
	</para>
	<section>
		<title>Portlet init</title>
	</section>
	<para>
		The main entry point for configuring a portlet is in the
		<emphasis role="bold">portlet.xml</emphasis>
		file located in the portlet application WAR. Every portlet that shall
		be built using the GateIn web framework must reference the
		<emphasis role="bold">PortletApplicationController</emphasis>
		. The portlet configuration such as the root component is defined in a
		<emphasis role="bold">configuration.xml</emphasis>
		file. The path to this configuration.xml file is defined in the
		init-param &quot;<emphasis role="bold">webui.configuration</emphasis>&quot; of porlet.xml.</para><programlisting>  &lt;portlet&gt;
    &lt;description xml:lang=&quot;EN&quot;&gt;Content Portlet&lt;/description&gt;
    &lt;portlet-name&gt;ContentPortlet&lt;/portlet-name&gt;
    &lt;display-name xml:lang=&quot;EN&quot;&gt;Content Portlet&lt;/display-name&gt;
    &lt;portlet-class&gt;org.exoplatform.webui.application.portlet.PortletApplicationController&lt;/portlet-class&gt;    
    
    &lt;init-param&gt;
      &lt;name&gt;webui.configuration&lt;/name&gt;
      &lt;value&gt;/WEB-INF/conf/portlet/content/ContentPortlet/webui/configuration.xml&lt;/value&gt;
    &lt;/init-param&gt;  
</programlisting><para>The structure of the <emphasis role="bold">configuration.xml</emphasis> file is exactly the same as the <emphasis>webui-configuration.xml</emphasis>which we have already introduced in the <link linkend="Portal Lifecycle">Portal Lifecycle</link> article. In the case of the content portlet it looks like:</para><programlisting>&lt;webui-configuration&gt;
  &lt;application&gt; 
    &lt;ui-component-root&gt;org.exoplatform.content.webui.component.UIContentPortlet&lt;/ui-component-root&gt;
    &lt;state-manager&gt;org.exoplatform.webui.application.portlet.ParentAppStateManager&lt;/state-manager&gt;
  &lt;/application&gt;
&lt;/webui-configuration&gt;
</programlisting><para>The <emphasis role="bold">PortletApplicationController</emphasis> class extends the <emphasis role="bold">GenericPortlet</emphasis> class defined in the Portlet API specification.</para><para>All methods like <emphasis>processAction()</emphasis> or <emphasis>render()</emphasis> are delegated to the <emphasis role="bold">PortletApplication</emphasis>. The creation and caching inside the <emphasis role="bold">WebController</emphasis> object is described in the following method:</para><programlisting>  /**
   * try to obtain the PortletApplication from the WebAppController.
   * 
   * If it does not exist a new PortletApplication object is created, init and cached in the
   * controller
   */
  private PortletApplication getPortletApplication() throws Exception {
    PortalContainer container = PortalContainer.getInstance() ;
    WebAppController controller = 
      (WebAppController)container.getComponentInstanceOfType(WebAppController.class) ;
    PortletApplication application = controller.getApplication(applicationId_) ;
    if(application == null) {
      application = new PortletApplication(getPortletConfig()) ;
      application.onInit() ; 
      controller.addApplication(application) ;
    }
    return application ;
  }
</programlisting>
<section><title>Portlet request handler</title></section>
<para>When a portlet, that is deployed in GateIn Portal, is using the GateIn web framework then all methods calls go through the <emphasis role="bold">PortletApplication</emphasis> object which extends the <emphasis role="bold">WebuiApplication</emphasis>.</para>
<section><title>ProcessAction phase</title></section>
<para>The code of the method in PortletApplication is described here. The business logic is shown in the javadoc:</para><programlisting>  /**
   * The processAction() method is the one modelled according to the Portlet API specification
   * 
   * The process is quite simple and here are te different steps done in the method:
   * 
   * 1) The current instance of the WebuiRequestContext (stored in a ThreadLocal in the class) is referenced
   * 2) A new request context of type PortletRequestContext (which extends the class WebuiRequestContext) is
   *    created as a child of the current context instance
   * 3) The new context is place inside the ThreadLocal and hence overides its parent one there, 
   *    only for the portlet request lifeciclye
   * 4) The method onStartRequest() is called in all the ApplicationLifecycle objects referenced in the webui 
   *    configuration XML file
   * 5) The StateManager object (in case of portlet it is an object of type ParentAppStateManager) is used to get the RootComponent
   *    also referenced in the XML configuration file
   * 6) The methods processDecode(UIApplication, WebuiRequestContext) and processAction(UIApplication, WebuiRequestContext) 
   *     are then called 
   * 7) Finally, a flag, to tell that the processAction phase was done, in the context is set to true and the parent
   *    context is restored in the Threadlocal
   */
  public void processAction(ActionRequest req, ActionResponse res) throws Exception {
    WebuiRequestContext parentAppRequestContext =  WebuiRequestContext.getCurrentInstance() ;
    PortletRequestContext context = createRequestContext(req, res, parentAppRequestContext)  ;
    WebuiRequestContext.setCurrentInstance(context) ;
    try {      
      for(ApplicationLifecycle lifecycle : getApplicationLifecycle())  {
        lifecycle.onStartRequest(this, context) ;
      } 
      UIApplication uiApp = getStateManager().restoreUIRootComponent(context) ;
      context.setUIApplication(uiApp) ;
      processDecode(uiApp, context) ;
      if(!images/context.isResponseComplete() &amp;&amp;!images/ context.getProcessRender()) {
        processAction(uiApp, context) ;
      }
    } finally {
      context.setProcessAction(true) ;
      WebuiRequestContext.setCurrentInstance(parentAppRequestContext) ;
    }
  }
</programlisting><para>The <emphasis role="bold">PortletRequestContext</emphasis> extends <emphasis role="bold">WebuiRequestContext</emphasis> class and acts as a wrapper on top of all the portlet request information:</para><programlisting>  /**
   * In this method we try to get the PortletRequestContext object from the attribute map of the parent 
   * WebuiRequestContext. 
   * 
   * If it is not cached then we create a new instance, if it is cached then we init it with the correct
   * writer, request and response objects
   * 
   * We finally cache it in the parent attribute map
   * 
   */
  private PortletRequestContext createRequestContext(PortletRequest req, PortletResponse res,
                                                    WebuiRequestContext parentAppRequestContext) throws IOException {
    String attributeName = getApplicationId() + &quot;$PortletRequest&quot; ;
    PortletRequestContext context = 
      (PortletRequestContext) parentAppRequestContext.getAttribute(attributeName) ;
    Writer w  = null ;       
    if(res instanceof  RenderResponse){
      RenderResponse renderRes = (RenderResponse)res;
      renderRes.setContentType(&quot;text/html; charset=UTF-8&quot;);      
      w = renderRes.getWriter() ; 
    }
    if(context!images/= null) {
      context.init(w, req, res) ;
    } else {
      context =  new PortletRequestContext(this, w, req, res) ;
      parentAppRequestContext.setAttribute(attributeName, context) ;
    }
    context.setParentAppRequestContext(parentAppRequestContext) ;
    return context;
  }  
</programlisting><para>In the PortletApplication, the line</para><itemizedlist><listitem><emphasis>UIApplication uiApp = getStateManager().restoreUIRootComponent(context);</emphasis> asks the StateManager defined for the portlet to get the UI root component. In the case of a portlet the root component must extend UIPortletApplication.</listitem></itemizedlist><programlisting>public class ParentAppStateManager extends StateManager {
  
  /**
   * This method simply delegate the call to the same method of the parent WebuiRequestContext
   */
  @SuppressWarnings(&quot;unchecked&quot;)
  public UIApplication restoreUIRootComponent(WebuiRequestContext context) throws Exception {
    WebuiRequestContext pcontext = (WebuiRequestContext)  context.getParentAppRequestContext() ;
    return pcontext.getStateManager().restoreUIRootComponent(context) ;
  }
</programlisting><para>Hence this is the PortalStateManager that will also handle the extraction of the root component.</para><programlisting>  public UIApplication restoreUIRootComponent(WebuiRequestContext context) throws Exception {
    context.setStateManager(this) ;
    WebuiApplication app  = (WebuiApplication)context.getApplication() ;
    
    /*
     * If the request context is of type PortletRequestContext, we extract the parent context which will
     * allow to get access to the PortalApplicationState object thanks to the session id used as the key for the
     * syncronised Map uiApplications
     */
    if(context instanceof PortletRequestContext) {
      WebuiRequestContext preqContext = (WebuiRequestContext) context.getParentAppRequestContext() ;
      PortalApplicationState state = uiApplications.get(preqContext.getSessionId()) ;
      PortletRequestContext pcontext = (PortletRequestContext) context ;
      String key =  pcontext.getApplication().getApplicationId() ;
      UIApplication uiApplication =  state.get(key) ;
      if(uiApplication!images/= null)  return uiApplication;
      synchronized(uiApplications) {
        ConfigurationManager cmanager = app.getConfigurationManager() ;
        String uirootClass = cmanager.getApplication().getUIRootComponent() ;
        Class type = Thread.currentThread().getContextClassLoader().loadClass(uirootClass) ;
        uiApplication = (UIApplication)app.createUIComponent(type, null, null, context) ;     
        state.put(key, uiApplication) ;
      }
      return uiApplication ;
    } 
</programlisting>
<section><title>Render phase</title></section>
<para>The render method business logic is quite similar to processAction().</para><programlisting>  /**
   * The render method business logic is quite similar to the processAction() one.
   * 
   * 1) A PortletRequestContext object is created (or extracted from the cache if it already exists) 
   *    and initialized
   * 2) The PortletRequestContext replaces the parent one in the WebuiRequestContext ThreadLocal object
   * 3) If the portal has already called the portlet processAction() then the call to all onStartRequest of
   *    the ApplicationLifecycle has already been made, otherwise we call them
   * 4) The ParentStateManager is also used to get the UIApplication, as we have seen it delegates the call 
   *    to the PortalStateManager which caches the UI component root associated with the current application
   * 5) the processRender() method of the UIPortletApplucaton is called
   * 6) Finally, the method onEndRequest() is called on every ApplicationLifecycle referenced in the portlet
   *    configuration XML file and the parent WebuiRequestContext is restored
   *    
   */
  public  void render(RenderRequest req,  RenderResponse res) throws Exception {    
    WebuiRequestContext parentAppRequestContext =  WebuiRequestContext.getCurrentInstance() ;
    PortletRequestContext context = createRequestContext(req, res, parentAppRequestContext)  ;
    WebuiRequestContext.setCurrentInstance(context) ;
    try {
      if(!context.hasProcessAction()) {
        for(ApplicationLifecycle lifecycle : getApplicationLifecycle())  {
          lifecycle.onStartRequest(this, context) ;
        }
      }      
      UIApplication uiApp =  getStateManager().restoreUIRootComponent(context) ;
      context.setUIApplication(uiApp) ;
      if(!context.isResponseComplete()) {
        UIPortletApplication uiPortletApp = (UIPortletApplication)uiApp;
        uiPortletApp.processRender(this, context) ;
      }
      uiApp.setLastAccessApplication(System.currentTimeMillis()) ;
    } finally {
      try {
        for(ApplicationLifecycle lifecycle :  getApplicationLifecycle()) {
          lifecycle.onEndRequest(this, context) ;
        }
      } catch (Exception exception){
    	log.error(&quot;Error while trying to call onEndRequest of the portlet ApplicationLifecycle&quot;, 
    		exception);
      }
      WebuiRequestContext.setCurrentInstance(parentAppRequestContext) ;
    }
  }
</programlisting><para>The processRender() call made on the UIPortletApplication is shown now:</para><programlisting>  /**
   * The default processRender for an UIPortletApplication handles two cases:
   * 
   *   A. Ajax is used 
   *   ~UWC_TOKEN_START~1255420331108~UWC_TOKEN_END~
   *     If Ajax is used and that the entire portal should not be re rendered, then an AJAX fragment is 
   *     generated with information such as the portlet id, the portlet title, the portlet modes, the window 
   *     states as well as the HTML for the block to render
   *   
   *   B. A full render is made
   *   ----
   *      a simple call to the method super.processRender(context) which will delegate the call to all the 
   *      Lifecycle components
   *   
   */
  public void  processRender(WebuiApplication app, WebuiRequestContext context) throws Exception {
    WebuiRequestContext pContext = (WebuiRequestContext)context.getParentAppRequestContext();
    if(context.useAjax() &amp;&amp;!images/pContext.getFullRender()) {
      Writer w =  context.getWriter() ;
      
      Set&lt;UIComponent&gt; list = context.getUIComponentToUpdateByAjax() ;
//      if(list == null) list = app.getDefaultUIComponentToUpdateByAjax(context) ;
      if(list!images/= null) {
        if(getUIPopupMessages().hasMessage()) context.addUIComponentToUpdateByAjax(getUIPopupMessages()) ;
        for(UIComponent uicomponent : list) {
          renderBlockToUpdate(uicomponent, context, w) ;
        }
        return ;
      }
    }
    super.processRender(context) ;    
  }
</programlisting>
</section>