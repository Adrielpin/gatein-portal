<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../../Reference_Guide.ent">
%BOOK_ENTITIES;
]>
<section id="sect-Reference_Guide-AJAX_Framework">
	<title>AJAX Framework</title>
		<para>
			Ajax calls are easily managed in &PRODUCT;'s framework. Lines can be added to the relevant template file and java class. A simple Ajax update of a component does not require any JavaScript code to be written.
		</para>
	
	<section id="sect-Reference_Guide-AJAX_Framework-Portlet_Preparation">
		<title>Portlet Preparation</title>
		<para>
			&PRODUCT; portlets can use specific <literal>ActionListener</literal>s to receive and process Ajax calls. To set a portlet up to recieve Ajax calls, follow this procedure:
		</para>	
		<procedure>
			<step>
				<para>
					Create an inner static class named with the following convention: <parameter>action name</parameter> followed by <literal>ActionListener</literal>.
				</para>
				<para>
					Example : <literal>ParentClass</literal> is the class being wrtitten in.
				</para>
						
<programlisting>static public class SaveActionListener extends EventListener&lt;ParentClass&gt;
</programlisting>
			</step>
			<step>
				<para>
					Declare this listener in the configuration of the portlet:
				</para>
					
<programlisting>listeners = ParentClass.SaveActionListener.class
</programlisting>
			</step>
			<step>
				<para>
					Add the correct annotation <literal>ComponentConfig</literal>, <literal>EventConfig</literal>, etc.
				</para>
				<para>
					For example; the configuration below is for <literal>UIAccountForm</literal>:
				</para>
						
<programlisting role="JAVA">...
@ComponentConfig(
  lifecycle = UIFormLifecycle.class,
  template =  "system:/groovy/webui/form/UIFormTabPane.gtmpl",
  initParams = {   
    @ParamConfig(
      name = "AccountTemplateConfigOption", 
      value = "app:/WEB-INF/conf/uiconf/account/webui/component/model/AccountTemplateConfigOption.groovy"
    ),
    @ParamConfig(
      name = "help.UIAccountFormQuickHelp",
      value = "app:/WEB-INF/conf/uiconf/account/webui/component/model/UIAccountFormQuickHelp.xhtml"
    )
  },
  events = {
    @EventConfig(listeners = UIAccountForm.SaveActionListener.class ),
    @EventConfig(listeners = UIAccountForm.ResetActionListener.class, phase = Phase.DECODE),
    @EventConfig(listeners = UIAccountForm.SearchUserActionListener.class, phase = Phase.DECODE)
  }
)
...
</programlisting>
			</step>
			<step>
				<para>
					Create an <literal>execute</literal> method inside this class:
				</para>
					
<programlisting>public void execute(Event&lt;ParentClass&gt; event) throws Exception
</programlisting>

				<para>
					This method is called every time the listener gets an event from the client. Hence you can process this event in it, using the even attribute. Use it to get parameters from a form in your client, to modify the status of your portlet, etc.,
				</para>
				<para>
					Possible ways to use the event attribute :
				</para>
				<itemizedlist>
					<listitem>
				
<programlisting role="XML">String value = event.getRequestContext().getRequestParameter("name"); // to get a value from a form
</programlisting>
					</listitem>
					<listitem>
				
<programlisting role="XML">ParentClass parent = event.getSource(); // to get the parent object (the portlet that threw and caugth the event)
</programlisting>
					</listitem>
					<listitem>
				
<programlisting role="XML">UIMyComponent portal = parent.getAncestorOfType(UIMyComponent.class); // to get  any node in the hierarchy of UIComponents
</programlisting>
					</listitem>
				</itemizedlist>
			</step>
			<step>
				<para>
					If your action has to update an element on your client's interface, you must call <emphasis role="bold">addUIComponentToUpdateByAjax() </emphasis> at the end of the <literal>execute</literal> method:
				</para>
						
<programlisting>event.getRequestContext().addUIComponentToUpdateByAjax(uicomponent);
</programlisting>
				<para>
					The target component must be provided as parameter (the component that will be updated). We will come back on this later.
				</para>
			</step>
			<step>
				<para>
					You must create one inner action listener class for each Ajax call you want to handle on this portlet. All these classes must be declared in the configuration annotations of the main class, otherwise you will get an error.
				</para>
			</step>
			<step>
				<para>
					Done. Your portlet is ready to accept Ajax calls from your client.
				</para>
			</step>
		</procedure>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_Framework-AJAX_in_Groovy">
		<title>AJAX in Groovy</title>
		<para>
			Once the server is configured to receive Ajax calls, you must configure the client interface to make these calls.
		</para>
		<procedure>
			<step>
				<para>
					Add the following code to the groovy template file associated with the appropriate portlet class ( <literal>ParentClass</literal> here):
				</para>
						
<programlisting>uicomponent.event("YourOperation");
</programlisting>
				<para>
					<literal>YourOperation</literal> is the same as in the <literal>ActionListener</literal> class (save in our example above).
				</para>
			</step>
			<step>
				<para>
					The event function will create an url starting with <literal>javascript:</literal>. Make sure this code can be executed in the environment where the portal is running.
				</para>
			</step>
			<step>
				<para>
					If your operation must update the content of a component, make sure that the target component is well rendered. The following is recommended:
				</para>
					
<programlisting>uicomponent.renderChild(UITargetComponent.class) ;
</programlisting>
			</step>
			<step>
				<para>
					The <literal>uicomponent</literal> must be of the <literal>UITargetComponent</literal> type as the component class; 
<programlisting>event.getRequestContext().addUIComponentToUpdateByAjax(uicomponent) ;
</programlisting> 
					will be updated when <literal>UITargetComponent</literal> is called. 
				</para>	
			</step>	
			<step>
				<para>
					If this component is not rendered by default, set its <literal>rendered</literal> attribute (in the constructor of the portlet) to false when the portlet loads:
				</para>
						
<programlisting>mycomponent.setRendered(false);
</programlisting>
			</step>
		</procedure>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_Framework-How_JavaScript_works">
		<title>How JavaScript works</title>
		<para>
			All javascript in &PRODUCT; is managed by the file <filename>02eXoresources:javascript/eXo/portal/PortalHttpRequest.js</filename>.
		</para>
		<para>
			In this class, there are four functions/classes: 
		</para>
		<formalpara>
			<title>PortletResponse</title>
			<para></para>
		</formalpara>
		<formalpara>
			<title>PortalResponse</title>
			<para></para>
		</formalpara>
		<formalpara>
			<title>AjaxRequest</title>
			<para></para>
		</formalpara>
		<formalpara>
			<title>HttpResponseHandler</title>
			<para></para>
		</formalpara>
		<para>
			and 6 functions:
		</para>
		<variablelist>
			<varlistentry>
				<term>ajaxGet(url, callback)</term>
					<listitem>
						<para>
							This is the main entry method for every Ajax calls to the portal It is simply a dispatcher method that completes some <parameter>init</parameter> fields before calling the <literal>doRequest()</literal> method.
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term>ajaxPost(formElement, callback)</term>
					<listitem>
						<para>
							This method is called instead of an <literal>HTTP POST</literal> when, in an AJAX case, some manipulations are needed. Once the content of the form is placed into a string object, the call is delegated to the <literal>doRequest()</literal> method
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term>doRequest(method, url, queryString, callback)</term>
					<listitem>
						<para>
							The <literal>doRequest()</literal> method takes incoming request from <literal>ajaxGet</literal> and <literal>ajaxPost</literal> calls. The second argument is the URL to target on the server The third argument is the query string object which is created out of a form element, this value is null except when there is a POST request. 
						<orderedlist>
							<listitem>
								<para>
									An <literal>AjaxRequest</literal> object is instantiated. It holds the reference to the XHR method.
								</para>
							</listitem>
							<listitem>
								<para>
									An <literal>HttpResponseHandler</literal> object is instantiated and its methods  (<literal>ajaxResponse</literal>, <literal>ajaxLoading</literal>, <literal>ajaxTimeout</literal>) are associated with the one from the <literal>AjaxRequest</literal> and will be called by the XHR during the process method.
								</para>
							</listitem>
						</orderedlist>
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term>ajaxAbort()</term>
					<listitem>
						<para>
							Cancels the current request.
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term>ajaxAsyncGetRequest(url, async)</term>
					<listitem>
						<para>
							Allows to create and execute a sync or async GET request.
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term>ajaxRedirect(url)</term>
					<listitem>
						<para>
							A simple javascript redirection with <literal>window.location.href</literal> that are the entry points of these classes. These functions need not be called explicitly, as the template file and the portlet class manage everything.
						</para>
					</listitem>
			</varlistentry>
		</variablelist>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_Framework-PortletResponse">
		<title>PortletResponse</title>
		<para>
			This class doesn't contain any methods. On creation, it retrieves the response elements from the xml returned by Ajax, and stores them in the corresponding attributes :
		</para>
		<variablelist>
			<varlistentry>
				<term>portletId</term>
				<listitem>
					<para>
						The component ID.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>portletTitle</term>
				<listitem>
					<para>
						The component title.
					</para>
				</listitem>
			</varlistentry>
			<varlistentry>
				<term>portletMode</term>
					<listitem>
						<para>
							The mode the component runs in. The options are: View, Edit, Help or Config.
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term>portletState</term>
					<listitem>
						<para>
							The processing state of the component. The options are: Decode, Render.
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term>portletData</term>
					<listitem>
						<para>
							The updated data to put in the component.
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term>script</term>
					<listitem>
						<para>
							The javascript code to update the component.
						</para>
					</listitem>
			</varlistentry>
			<varlistentry>
				<term>blocksToUpdate</term> 
					<listitem>
						<para>
							An array containing the containers to update with this script.
						</para>
					</listitem>
			</varlistentry>
		</variablelist>
		<para>
			Attributes can be accessed by calling them from the <literal>PortletResponse</literal> instance.
		</para>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_Framework-PortalResponse">
		<title>PortalResponse</title>
		<para>
			This is an array of <literal>PortletResponse</literal>s (<literal>portletResponses</literal>) and two other attributes:
		</para>
		<variablelist>
		  <varlistentry>
			<term>data</term>
			<listitem>
				<para>
					Data to update.
				</para>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>script</term>
			<listitem>
				<para>
					Javascript code to update.
				</para>
			</listitem>
		</varlistentry>
		</variablelist>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_Framework-AjaxRequest">
		<title>AjaxRequest</title>
		<para>
			By far the most important class of this file. It makes the <literal>XMLHttpRequest</literal> object easier to use by wrapping it with functions and attributes. You can find further documentation on this class <ulink type="http" url="http://www.ajaxtoolbox.com/request/documentation.php">here</ulink>.
		</para>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_Framework-HttpResponseHandler">
		<title>HttpResponseHandler</title>
		<para>
			This class provides methods to handle the Ajax response.
		</para>
		<variablelist>
		  <varlistentry>
			<term>executeScript</term>
			<listitem>
				<para>
					Used to execute javascript code.
				</para>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>updateBlocks</term>
			<listitem>
				<para>
					Updates <literal>html</literal> components.
				</para>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>ajaxTimeout</term>
			<listitem>
				<para>
					This function is called when the timeout of the ajax call exceeds its set limit.
				</para>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>ajaxResponse</term>
			<listitem>
				<para>
					This function creates a <literal>PortalResponse</literal> object from the data in the Ajax request.
				</para>
			</listitem>
		</varlistentry>
		<varlistentry>
			<term>ajaxLoading</term>
			<listitem>
				<para>
					This function shows the loading pop-up and mask layer.
				</para>
			</listitem>
		</varlistentry>
		</variablelist>

		<formalpara>
		<title>Portal Ajax Response Data Structure:</title>
			<para>
<programlisting>{PortalResponse}
  |
  |---&gt;{PortletResponse}
  |
  |---&gt;{PortletResponse}
  |          |--&gt;{portletId}
  |          |--&gt;{portletTitle}
  |          |--&gt;{portletMode}
  |          |--&gt;{portletState}
  |          |
  |          |--&gt;{Data}
  |          |      |
  |          |      |---&gt;{BlockToUpdate}
  |          |      |         |--&gt;{blockId}
  |          |      |         |--&gt;{data}
  |          |      |
  |          |      |---&gt;{BlockToUpdate}
  |          |---&gt;{Script}
  |
  |---&gt;{Data}
  |      |
  |      |---&gt;{BlockToUpdate}
  |      |         |--&gt;{blockId}
  |      |         |--&gt;{data}
  |      |
  |      |---&gt;{BlockToUpdate}
  |---&gt;{Script}
</programlisting>
			</para>
		</formalpara>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_Framework-Manage_Several_Popups">
		<title>Manage Several Popups</title>
		<para>
			If there are several actions that need to appear in a pop-up, the following technique can be used to manage the different pop-up windows:
		</para>
		<procedure>
			<step>
				<para>
					Create a <literal>UIPopupAction</literal> in the main portlet class:
				</para>
<programlisting>addChild(UIPopupAction.class, null, null);
</programlisting>
			</step>
			<step>
				<para>
					Render this action in your template file:
				</para>
<programlisting>uicomponent.renderChild(UIPopupAction.class) ;
</programlisting>

				<para>
					(This creates an empty container (pop-up) that will receive the new content by Ajax)
				</para>
			</step>
			<step>
				<para>
					Put this component in your action listener class and update its content:
				</para>
<programlisting>UIPopupAction uiPopupAction = uiMainPortlet.getChild(UIPopupAction.class) ;
uiPopupAction.activate(UIReferencesList.class, 600) ;
</programlisting>
				<para>
					<literal>UIReferenceList</literal> is the component that will appear in the pop-up. It does not have to declared in the main portlet class. 
				</para>	
				<para>
					The activate method creates the component and its rendering in the pop-up window.
				</para>
			</step>
			<step>
				<para>
					Allow this component to be updated by Ajax:
				</para>
<programlisting>event.getRequestContext().addUIComponentToUpdateByAjax(uiPopupAction) ;
</programlisting>
			</step>
			<step>
				<para>
					Add an action listener class (and repeat the steps above with the appropriate component type) for each component required to appear in a pop-up window .
				</para>
			</step>
		</procedure>
	</section>

</section>


