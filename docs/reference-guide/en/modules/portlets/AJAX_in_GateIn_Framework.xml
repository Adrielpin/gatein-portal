<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../../Reference_Guide.ent">
%BOOK_ENTITIES;
]>
<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework">
	<title>AJAX in GateIn Framework</title>
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-Overview">
		<title>Overview</title>
		<para>
			It is very easy to create and manage Ajax calls in our framework. Just a few lines to write in your template file and your java class. For simple Ajax update of a component, you don't even have to write any line of JavaScript.
		</para>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-Portlet_Preparation">
		<title>Portlet Preparation</title>
		<para>
			Our portlets can use specific <literal>ActionListener</literal> s to receive and process Ajax calls. To do that, you must create an inner static class named following this convention : action name followed by ActionListener
		</para>
		<para>
			Example : <literal>ParentClass</literal> is the class in which you are writing.
		</para>
		
<programlisting>static public class SaveActionListener extends EventListener&lt;ParentClass&gt;
</programlisting>
		<para>
			Don't forget to declare this listener in the configuration of your portlet, like this :
		</para>
		
<programlisting>listeners = ParentClass.SaveActionListener.class
</programlisting>
		<para>
			along with the correct annotation <literal>ComponentConfig</literal> , <literal>EventConfig</literal> , etc.,
		</para>
		<para>
			For example, the configuration for <literal>UIAccountForm</literal> :
		</para>
		
<programlisting role="JAVA">...
@ComponentConfig(
  lifecycle = UIFormLifecycle.class,
  template =  "system:/groovy/webui/form/UIFormTabPane.gtmpl",
  initParams = {   
    @ParamConfig(
      name = "AccountTemplateConfigOption", 
      value = "app:/WEB-INF/conf/uiconf/account/webui/component/model/AccountTemplateConfigOption.groovy"
    ),
    @ParamConfig(
      name = "help.UIAccountFormQuickHelp",
      value = "app:/WEB-INF/conf/uiconf/account/webui/component/model/UIAccountFormQuickHelp.xhtml"
    )
  },
  events = {
    @EventConfig(listeners = UIAccountForm.SaveActionListener.class ),
    @EventConfig(listeners = UIAccountForm.ResetActionListener.class, phase = Phase.DECODE),
    @EventConfig(listeners = UIAccountForm.SearchUserActionListener.class, phase = Phase.DECODE)
  }
)
...
</programlisting>
		<para>
			Inside this class, you will have to create an <literal>execute</literal> method like this :
		</para>
		
<programlisting>public void execute(Event&lt;ParentClass&gt; event) throws Exception
</programlisting>
		<para>
			This method is called every time the listener gets an event from the client, hence you can process this event in it, using the even attribute. Use it to get parameters from a form in your client, to modify the status of your portlet, etc.,
		</para>
		<para>
			Possible ways to use the event attribute :
		</para>
		<itemizedlist>
			<listitem>
				
<programlisting role="XML">String value = event.getRequestContext().getRequestParameter("name"); // to get a value from a form
</programlisting>
			</listitem>
			<listitem>
				
<programlisting role="XML">ParentClass parent = event.getSource(); // to get the parent object (the portlet that threw and caugth the event)
</programlisting>
			</listitem>
			<listitem>
				
<programlisting role="XML">UIMyComponent portal = parent.getAncestorOfType(UIMyComponent.class); // to get  any node in the hierarchy of UIComponents
</programlisting>
			</listitem>
		</itemizedlist>
		<para>
			If your action has to update an element on your client's interface, you must call <emphasis role="bold">addUIComponentToUpdateByAjax() </emphasis> at the end of the <literal>execute</literal> method:
		</para>
		
<programlisting>event.getRequestContext().addUIComponentToUpdateByAjax(uicomponent);
</programlisting>
		<para>
			The target component must be provided as parameter (the component that will be updated). We will come back on this later.
		</para>
		<para>
			You must create one inner action listener class for each Ajax call you want to handle on this portlet. All these classes must be declared in the configuration annotations of the main class, otherwise you will get an error.
		</para>
		<para>
			Done. Your portlet is ready to accept Ajax calls from your client.
		</para>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-AJAX_in_the_Groovy_template">
		<title>AJAX in the Groovy template</title>
		<para>
			Your server being configured to receive Ajax calls, you must configure the client interface to make these calls.
		</para>
		<para>
			In the groovy template file associated with your portlet class ( <literal>ParentClass</literal> here), you just have to add :
		</para>
		
<programlisting>uicomponent.event("YourOperation"); // YourOperation is the same as in the ActionListener class (Save in our example above)
</programlisting>
		<para>
			in a groovy code block. The event function will create an url starting with <literal>javascript:</literal> so you have to make sure this code can be executed in your environment.
		</para>
		<para>
			If your operation must update the content of a component, you have to make sure that the target component is well rendered. Basically, just type this :
		</para>
		
<programlisting>uicomponent.renderChild(UITargetComponent.class) ;
</programlisting>
		<para>
			in a groovy code block. <literal>UITargetComponent</literal> is the class of the component that will be updated when
		</para>
		
<programlisting>event.getRequestContext().addUIComponentToUpdateByAjax(uicomponent) ;
</programlisting>
		<para>
			is called. Hence, <literal>uicomponent</literal> must be of type <literal>UITargetComponent</literal> . If this component is not rendered by default, when the portlet loads, don't forget to set its <literal>rendered</literal> attribute to false :
		</para>
		
<programlisting>mycomponent.setRendered(false);
</programlisting>
		<para>
			in the constructor of your portlet.
		</para>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-How_JavaScript_works">
		<title>How JavaScript works</title>
		<para>
			All the javascript is managed by the file <filename>02eXoresources:javascript/eXo/portal/PortalHttpRequest.js</filename> in the portal project.
		</para>
		<para>
			In this class, you will find 4 functions/classes (detailed below): 
			<itemizedlist>
				<listitem>
					<para>
						PortletResponse
					</para>
				</listitem>
				<listitem>
					<para>
						PortalResponse
					</para>
				</listitem>
				<listitem>
					<para>
						AjaxRequest
					</para>
				</listitem>
				<listitem>
					<para>
						HttpResponseHandler
					</para>
				</listitem>
			</itemizedlist>
		</para>
		<para>
			and 6 functions:
		</para>
		<itemizedlist>
			<listitem>
				<para>
					ajaxGet(url, callback)
				</para>
				<para>
					This is the main entry method for every Ajax calls to the GateIn Portal It is simply a dispatcher method that fills some init fields before calling the doRequest() method
				</para>
			</listitem>
			<listitem>
				<para>
					ajaxPost(formElement, callback) // Calls doRequest with an url in POST mode
				</para>
				<para>
					This method is called when a HTTP POST should be done but in an AJAX case some maniputalions are needed. Once the content of the form is placed into a string object, the call is delegated to the doRequest() method
				</para>
			</listitem>
			<listitem>
				<para>
					doRequest(method, url, queryString, callback)
				</para>
				<para>
					The doRequest() method takes incoming request from GET and POST calls The second argument is the URL to target on the server The third argument is the query string object which is created out of a form element, this value is not null only when there is a POST request. 
					<orderedlist>
						<listitem>
							<para>
								An AjaxRequest object is instanciated, it holds the reference to the XHR method
							</para>
						</listitem>
						<listitem>
							<para>
								An HttpResponseHandler object is instantiated and its methods like ajaxResponse, ajaxLoading, ajaxTimeout are associated with the one from the AjaxRequest and will be called by the XHR during the process method
							</para>
						</listitem>
					</orderedlist>
				</para>
			</listitem>
			<listitem>
				<para>
					ajaxAbort()
				</para>
				<para>
					Cancels the current request
				</para>
			</listitem>
			<listitem>
				<para>
					ajaxAsyncGetRequest(url, async)
				</para>
				<para>
					Allows to create and execute a sync or async GET request
				</para>
			</listitem>
			<listitem>
				<para>
					ajaxRedirect(url)
				</para>
				<para>
					A simple javascript redirection with window.location.href that are the entry points of these classes. You shouldn't have to call explicitly these functions, since the template file and the portlet class manage everything.
				</para>
			</listitem>
		</itemizedlist>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-PortletResponse">
		<title>PortletResponse</title>
		<para>
			This class doesn't contain any method. On creation, it just gets the response elements from the xml returned by Ajax, and store them in the corresponding attributes :
		</para>
		<itemizedlist>
			<listitem>
				<para>
					portletId
				</para>
			</listitem>
			<listitem>
				<para>
					portletTitle
				</para>
			</listitem>
			<listitem>
				<para>
					portletMode // View, Edit, Help or Config
				</para>
			</listitem>
			<listitem>
				<para>
					portletState // Decode, Render
				</para>
			</listitem>
			<listitem>
				<para>
					portletData // The updated data to put in the component
				</para>
			</listitem>
			<listitem>
				<para>
					script //The javascript code to update the component
				</para>
			</listitem>
			<listitem>
				<para>
					blocksToUpdate // An array containing the containers to update with this script
				</para>
			</listitem>
		</itemizedlist>
		<para>
			You can access these attributes just by calling them from your <literal>PortletResponse</literal> instance.
		</para>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-PortalResponse">
		<title>PortalResponse</title>
		<para>
			Contains an array of <literal>PortletResponse</literal> s ( <literal>portletResponses</literal> ) and two other attributes :
		</para>
		<itemizedlist>
			<listitem>
				<para>
					data // Data to update
				</para>
			</listitem>
			<listitem>
				<para>
					script // Javascript code to update
				</para>
			</listitem>
		</itemizedlist>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-AjaxRequest">
		<title>AjaxRequest</title>
		<para>
			By far the most important class of this file. Wraps the XMLHttpRequest object with some functions and attributes, to make it easier to use. You can find the complete documentation here : http://www.ajaxtoolbox.com/request/documentation.php
		</para>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-HttpResponseHandler">
		<title>HttpResponseHandler</title>
		<para>
			This class provides methods to handle the Ajax response.
		</para>
		<itemizedlist>
			<listitem>
				<para>
					executeScript // execute some javascript
				</para>
			</listitem>
			<listitem>
				<para>
					updateBlocks // update some html components
				</para>
			</listitem>
			<listitem>
				<para>
					ajaxTimeout // a function called when the timeout of the ajax call exceeds. Just cancel the request
				</para>
			</listitem>
			<listitem>
				<para>
					ajaxResponse // creates a PortalResponse object from the data from the Ajax request
				</para>
			</listitem>
			<listitem>
				<para>
					ajaxLoading // shows the loading popup and mask layer
				</para>
			</listitem>
		</itemizedlist>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-Portal_Ajax_Response_Data_Structure">
		<title>Portal Ajax Response Data Structure</title>
		
<programlisting>{PortalResponse}
  |
  |---&gt;{PortletResponse}
  |
  |---&gt;{PortletResponse}
  |          |--&gt;{portletId}
  |          |--&gt;{portletTitle}
  |          |--&gt;{portletMode}
  |          |--&gt;{portletState}
  |          |
  |          |--&gt;{Data}
  |          |      |
  |          |      |---&gt;{BlockToUpdate}
  |          |      |         |--&gt;{blockId}
  |          |      |         |--&gt;{data}
  |          |      |
  |          |      |---&gt;{BlockToUpdate}
  |          |---&gt;{Script}
  |
  |---&gt;{Data}
  |      |
  |      |---&gt;{BlockToUpdate}
  |      |         |--&gt;{blockId}
  |      |         |--&gt;{data}
  |      |
  |      |---&gt;{BlockToUpdate}
  |---&gt;{Script}
</programlisting>
	</section>
	
	<section id="sect-Reference_Guide-AJAX_in_GateIn_Framework-Manage_Several_Popups">
		<title>Manage Several Popups</title>
		<para>
			If you have several actions that need to appear in a popup, you can use this technique to manage the different popup windows easily:
		</para>
		<para>
			Create a <literal>UIPopupAction</literal> in your main portlet class:
		</para>
		
<programlisting>addChild(UIPopupAction.class, null, null);
</programlisting>
		<para>
			and render it in your template file:
		</para>
		
<programlisting>uicomponent.renderChild(UIPopupAction.class) ;
</programlisting>
		<para>
			By default, this just create an empty container (popup) that will receive the new content by Ajax.
		</para>
		<para>
			Get this component in your action listener class, and update its content:
		</para>
		
<programlisting>UIPopupAction uiPopupAction = uiMainPortlet.getChild(UIPopupAction.class) ;
uiPopupAction.activate(UIReferencesList.class, 600) ;
</programlisting>
		<para>
			UIReferenceList is the component that will appear in the popup. You don't have to declare it in the main portlet class. The activate method takes care of the creation of the component, and its rendering in the popup window. See the javadoc for more information on this class.
		</para>
		<para>
			Make this component updatable by Ajax:
		</para>
		
<programlisting>event.getRequestContext().addUIComponentToUpdateByAjax(uiPopupAction) ;
</programlisting>
		<para>
			For each component that you want that component to appear in a popup window, add a action listener class and repeat the steps above with the appropriate component type.
		</para>
	</section>

</section>


