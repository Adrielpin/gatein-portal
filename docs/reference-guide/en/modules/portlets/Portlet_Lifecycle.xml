<?xml version='1.0' encoding='utf-8' ?>
<!DOCTYPE section PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY % BOOK_ENTITIES SYSTEM "../../Reference_Guide.ent">
%BOOK_ENTITIES;
]>
<section id="sect-Reference_Guide-Portlet_Lifecycle">
	<title>Portlet Lifecycle</title>
		<para>
			This chapter does not to refer to the Portlet API specification lifecycle but focuses on the &PRODUCT; UI framework.
		</para>
		<para>
			This web framework has been developed specifically for &PRODUCT; and, while it is not necessary to use the native web framework to build portlets, all portlets packaged with &PRODUCT; are developed using this framework.
		</para>
		<para>	
			This consistency allows portlets to use several UI components that can be used in different abstracted contexts (such as the portal itself or some portlets).
		</para>
		<note>
			<title>Recommended Reading</title>
			<para>
				This chapter is intended for advanced developers. It covers code implementation and logic. It is not a tutorial on how to write portlets.
			</para>
			<para>
				Refer to <xref linkend="sect-Reference_Guide-Portal_Lifecycle" /> for information on concepts that are similar and top hierarchy classes that are shared.
			</para>
		</note>

	<section id="sect-Reference_Guide-Portlet_Lifecycle-Portlet_init">
		<title>Portlet init</title>
		<para>
			The main entry point for configuring a portlet is in the <emphasis role="bold">portlet.xml</emphasis> file located in the portlet application WAR. 
		</para>
		<para>
			Each portlet built using the &PRODUCT; web framework must reference the <emphasis role="bold">PortletApplicationController</emphasis> . 
		</para>
		<para>
			The portlet configuration (such as the root component) is defined in <filename>configuration.xml</filename>. The path to this file is defined in the init-param "<emphasis role="bold">webui.configuration</emphasis>" of <filename>portlet.xml</filename>.
		</para>
		
<programlisting>&lt;portlet&gt;
  &lt;description xml:lang="EN"&gt;Content Portlet&lt;/description&gt;
  &lt;portlet-name&gt;ContentPortlet&lt;/portlet-name&gt;
  &lt;display-name xml:lang="EN"&gt;Content Portlet&lt;/display-name&gt;
  &lt;portlet-class&gt;org.exoplatform.webui.application.portlet.PortletApplicationController&lt;/portlet-class&gt;    
    
  &lt;init-param&gt;
    &lt;name&gt;webui.configuration&lt;/name&gt;
    &lt;value&gt;/WEB-INF/conf/portlet/content/ContentPortlet/webui/configuration.xml&lt;/value&gt;
  &lt;/init-param&gt;
&lt;/portlet&gt;
</programlisting>
		<para>
			The structure of the <filename>configuration.xml</filename> file is exactly the same as the <filename>webui-configuration.xml</filename> which was introduced in <xref linkend="sect-Reference_Guide-Portal_Lifecycle" />. 
		</para>
		<para>
			In the case of the content portlet it is formatted as:
		</para>
		
<programlisting>&lt;webui-configuration&gt;
  &lt;application&gt; 
    &lt;ui-component-root&gt;org.exoplatform.content.webui.component.UIContentPortlet&lt;/ui-component-root&gt;
    &lt;state-manager&gt;org.exoplatform.webui.application.portlet.ParentAppStateManager&lt;/state-manager&gt;
  &lt;/application&gt;
&lt;/webui-configuration&gt;
</programlisting>
		<para>
			The <literal>PortletApplicationController</literal> class extends the <literal>GenericPortlet</literal> class defined in the Portlet API specification.
		</para>
		<para>
			All methods (like <literal>processAction()</literal> or <literal>render()</literal>) are delegated to the <literal>PortletApplication</literal>. The creation and caching inside the <literal>WebController</literal> object is shown in the example below:
		</para>
		
<programlisting>/**
 * try to obtain the PortletApplication from the WebAppController.
 * 
 * If it does not exist a new PortletApplication object is created, init and cached in the
 * controller
 */
private PortletApplication getPortletApplication() throws Exception {
  PortalContainer container = PortalContainer.getInstance() ;
  WebAppController controller = 
    (WebAppController)container.getComponentInstanceOfType(WebAppController.class) ;
  PortletApplication application = controller.getApplication(applicationId_) ;
  if(application == null) {
    application = new PortletApplication(getPortletConfig()) ;
    application.onInit() ; 
    controller.addApplication(application) ;
  }
  return application ;
}
</programlisting>
	</section>
	
	<section id="sect-Reference_Guide-Portlet_Lifecycle-Portlet_request_handler">
		<title>Portlet request handler</title>
		<para>
			When a portlet using the native web framework is deployed in &PRODUCT;, all methods calls go through the <literal>PortletApplication</literal> object which extends the <literal>WebuiApplication</literal>.
		</para>
	</section>
	
	<section id="sect-Reference_Guide-Portlet_Lifecycle-ProcessAction_phase">
		<title>ProcessAction phase</title>
		<para>
			The code of the method in <literal>PortletApplication</literal> is described below. The business logic is shown in the javadoc:
		</para>
		
<programlisting>/**
 * The processAction() method is the one modelled according to the Portlet API specification
 * 
 * The process is quite simple and here are te different steps done in the method:
 * 
 * 1) The current instance of the WebuiRequestContext (stored in a ThreadLocal in the class) is referenced
 * 2) A new request context of type PortletRequestContext (which extends the class WebuiRequestContext) is
 *    created as a child of the current context instance
 * 3) The new context is place inside the ThreadLocal and hence overides its parent one there, 
 *    only for the portlet request lifeciclye
 * 4) The method onStartRequest() is called in all the ApplicationLifecycle objects referenced in the webui 
 *    configuration XML file
 * 5) The StateManager object (in case of portlet it is an object of type ParentAppStateManager) is used to get the RootComponent
 *    also referenced in the XML configuration file
 * 6) The methods processDecode(UIApplication, WebuiRequestContext) and processAction(UIApplication, WebuiRequestContext) 
 *     are then called 
 * 7) Finally, a flag, to tell that the processAction phase was done, in the context is set to true and the parent
 *    context is restored in the Threadlocal
 */
public void processAction(ActionRequest req, ActionResponse res) throws Exception {
  WebuiRequestContext parentAppRequestContext =  WebuiRequestContext.getCurrentInstance() ;
  PortletRequestContext context = createRequestContext(req, res, parentAppRequestContext)  ;
  WebuiRequestContext.setCurrentInstance(context) ;
  try {      
    for(ApplicationLifecycle lifecycle : getApplicationLifecycle())  {
      lifecycle.onStartRequest(this, context) ;
    } 
    UIApplication uiApp = getStateManager().restoreUIRootComponent(context) ;
    context.setUIApplication(uiApp) ;
    processDecode(uiApp, context) ;
    if(!images/context.isResponseComplete() &amp;&amp;!images/ context.getProcessRender()) {
      processAction(uiApp, context) ;
    }
  } finally {
    context.setProcessAction(true) ;
    WebuiRequestContext.setCurrentInstance(parentAppRequestContext) ;
  }
}
</programlisting>
		<para>
			The <literal>PortletRequestContext</literal> extends the <literal>WebuiRequestContext</literal> class and acts as a wrapper on all the portlet request information:
		</para>
		
<programlisting>/**
 * In this method we try to get the PortletRequestContext object from the attribute map of the parent 
 * WebuiRequestContext. 
 * 
 * If it is not cached then we create a new instance, if it is cached then we init it with the correct
 * writer, request and response objects
 * 
 * We finally cache it in the parent attribute map
 * 
 */
private PortletRequestContext createRequestContext(PortletRequest req, PortletResponse res,
                                                  WebuiRequestContext parentAppRequestContext) throws IOException {
  String attributeName = getApplicationId() + "$PortletRequest" ;
  PortletRequestContext context = 
    (PortletRequestContext) parentAppRequestContext.getAttribute(attributeName) ;
  Writer w  = null ;       
  if(res instanceof  RenderResponse){
    RenderResponse renderRes = (RenderResponse)res;
    renderRes.setContentType("text/html; charset=UTF-8");      
    w = renderRes.getWriter() ; 
  }
  if(context!images/= null) {
    context.init(w, req, res) ;
  } else {
    context =  new PortletRequestContext(this, w, req, res) ;
    parentAppRequestContext.setAttribute(attributeName, context) ;
  }
  context.setParentAppRequestContext(parentAppRequestContext) ;
  return context;
}
</programlisting>
		<para>
			In the <literal>PortletApplication</literal>, the line;
		</para>
<programlisting>UIApplication uiApp = getStateManager().restoreUIRootComponent(context);
</programlisting>
		<para>
			 asks the <literal>StateManager</literal> defined for the portlet to get the UI root component. In the case of a portlet the root component must extend <literal>UIPortletApplication</literal>.
		</para>
		
<programlisting>public class ParentAppStateManager extends StateManager {
  
  /**
   * This method simply delegate the call to the same method of the parent WebuiRequestContext
   */
  @SuppressWarnings("unchecked")
  public UIApplication restoreUIRootComponent(WebuiRequestContext context) throws Exception {
    WebuiRequestContext pcontext = (WebuiRequestContext)  context.getParentAppRequestContext() ;
    return pcontext.getStateManager().restoreUIRootComponent(context) ;
  }
</programlisting>
		<para>
			Hence this is the PortalStateManager that will also handle the extraction of the root component.
		</para>
		
<programlisting>public UIApplication restoreUIRootComponent(WebuiRequestContext context) throws Exception {
  context.setStateManager(this) ;
  WebuiApplication app  = (WebuiApplication)context.getApplication() ;
  
  /*
   * If the request context is of type PortletRequestContext, we extract the parent context which will
   * allow to get access to the PortalApplicationState object thanks to the session id used as the key for the
   * syncronised Map uiApplications
   */
  if(context instanceof PortletRequestContext) {
    WebuiRequestContext preqContext = (WebuiRequestContext) context.getParentAppRequestContext() ;
    PortalApplicationState state = uiApplications.get(preqContext.getSessionId()) ;
    PortletRequestContext pcontext = (PortletRequestContext) context ;
    String key =  pcontext.getApplication().getApplicationId() ;
    UIApplication uiApplication =  state.get(key) ;
    if(uiApplication!images/= null)  return uiApplication;
    synchronized(uiApplications) {
      ConfigurationManager cmanager = app.getConfigurationManager() ;
      String uirootClass = cmanager.getApplication().getUIRootComponent() ;
      Class type = Thread.currentThread().getContextClassLoader().loadClass(uirootClass) ;
      uiApplication = (UIApplication)app.createUIComponent(type, null, null, context) ;     
      state.put(key, uiApplication) ;
    }
    return uiApplication ;
  }
}
</programlisting>
	</section>
	
	<section id="sect-Reference_Guide-Portlet_Lifecycle-Render_phase">
		<title>Render phase</title>
		<para>
			The render method business logic is quite similar to <literal>processAction()</literal>.
		</para>
		
<programlisting>/**
 * The render method business logic is quite similar to the processAction() one.
 * 
 * 1) A PortletRequestContext object is created (or extracted from the cache if it already exists) 
 *    and initialized
 * 2) The PortletRequestContext replaces the parent one in the WebuiRequestContext ThreadLocal object
 * 3) If the portal has already called the portlet processAction() then the call to all onStartRequest of
 *    the ApplicationLifecycle has already been made, otherwise we call them
 * 4) The ParentStateManager is also used to get the UIApplication, as we have seen it delegates the call 
 *    to the PortalStateManager which caches the UI component root associated with the current application
 * 5) the processRender() method of the UIPortletApplucaton is called
 * 6) Finally, the method onEndRequest() is called on every ApplicationLifecycle referenced in the portlet
 *    configuration XML file and the parent WebuiRequestContext is restored
 *    
 */
public  void render(RenderRequest req,  RenderResponse res) throws Exception {    
  WebuiRequestContext parentAppRequestContext =  WebuiRequestContext.getCurrentInstance() ;
  PortletRequestContext context = createRequestContext(req, res, parentAppRequestContext)  ;
  WebuiRequestContext.setCurrentInstance(context) ;
  try {
    if(!context.hasProcessAction()) {
      for(ApplicationLifecycle lifecycle : getApplicationLifecycle())  {
        lifecycle.onStartRequest(this, context) ;
      }
    }      
    UIApplication uiApp =  getStateManager().restoreUIRootComponent(context) ;
    context.setUIApplication(uiApp) ;
    if(!context.isResponseComplete()) {
      UIPortletApplication uiPortletApp = (UIPortletApplication)uiApp;
      uiPortletApp.processRender(this, context) ;
    }
    uiApp.setLastAccessApplication(System.currentTimeMillis()) ;
  } finally {
    try {
      for(ApplicationLifecycle lifecycle :  getApplicationLifecycle()) {
        lifecycle.onEndRequest(this, context) ;
      }
    } catch (Exception exception){
  	log.error("Error while trying to call onEndRequest of the portlet ApplicationLifecycle", 
  		exception);
    }
    WebuiRequestContext.setCurrentInstance(parentAppRequestContext) ;
  }
}
</programlisting>
		<para>
			The following is the <literal>processRender()</literal> call made on the <literal>UIPortletApplication</literal>:
		</para>
		
<programlisting>/**
 * The default processRender for an UIPortletApplication handles two cases:
 * 
 *   A. Ajax is used 
 *   ----
 *     If Ajax is used and that the entire portal should not be re rendered, then an AJAX fragment is 
 *     generated with information such as the portlet id, the portlet title, the portlet modes, the window 
 *     states as well as the HTML for the block to render
 *   
 *   B. A full render is made
 *   ----
 *      a simple call to the method super.processRender(context) which will delegate the call to all the 
 *      Lifecycle components
 *   
 */
public void  processRender(WebuiApplication app, WebuiRequestContext context) throws Exception {
  WebuiRequestContext pContext = (WebuiRequestContext)context.getParentAppRequestContext();
  if(context.useAjax() &amp;&amp;!images/pContext.getFullRender()) {
    Writer w =  context.getWriter() ;
    
    Set&lt;UIComponent&gt; list = context.getUIComponentToUpdateByAjax() ;
    if(list!images/= null) {
      if(getUIPopupMessages().hasMessage()) context.addUIComponentToUpdateByAjax(getUIPopupMessages()) ;
      for(UIComponent uicomponent : list) {
        renderBlockToUpdate(uicomponent, context, w) ;
      }
      return ;
    }
  }
  super.processRender(context) ;    
}
</programlisting>
	</section>

</section>


